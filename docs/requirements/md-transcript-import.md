# Импорт готовых MD-транскриптов

> Поддержка готовых файлов транскриптов (.md) из MacWhisper как источника для pipeline

**Статус:** Draft
**Дата:** 2026-02-19
**Версии:** v0.64 (план)

---

## 1. Проблема

При записи тем на выездных мероприятиях сложно точно определить начало и конец темы, не отвлекаясь от содержания. Поэтому записывается вся часть мероприятия с несколькими темами целиком.

Затем аудиозапись транскрибируется в MacWhisper (модель Large v2), где определяются спикеры и вырезается точный фрагмент с темой конкретного спикера.

**Текущая ситуация:**
- Pipeline принимает только медиафайлы (видео/аудио)
- Готовые транскрипты из MacWhisper приходится обрабатывать вручную

**Почему это проблема:**
- Дублирование работы — транскрипт уже готов, но pipeline требует медиафайл
- Невозможно использовать преимущества diarization MacWhisper (определение спикеров)
- Выездные мероприятия с несколькими темами не вписываются в текущий workflow "один файл = одна тема"

---

## 2. Решение

Добавить `.md` как валидный тип входного файла в inbox. При обнаружении `.md` файла — пропускать шаг Whisper-транскрибации и загружать содержимое файла как готовый транскрипт. Остальной pipeline (clean → longread/story → chunk → save) работает без изменений.

### Ключевые идеи

1. **Минимальные изменения в pipeline** — только inbox + transcribe stage, остальные этапы не затрагиваются
2. **Тот же формат имени файла** — dated offsite паттерн с точкой: `{YYYY.MM} {Event}. [#] {Title} ({Speaker}).md`
3. **Clean stage обязателен** — MacWhisper Large v2 тоже допускает ошибки транскрибирования
4. **Оценка длительности по словам** — ~130 слов/мин (средняя скорость речи на русском)

### Архитектура

```
Текущий flow (медиафайл):
  Video/Audio → Parse → [Whisper] → Clean → Longread/Story → Chunk → Save

Новый flow (MD-транскрипт):
  .md file → Parse → [Load file] → Clean → Longread/Story → Chunk → Save
                       ↑
                  Whisper пропущен,
                  текст загружен из файла
```

---

## 3. Пользовательский сценарий

```
1. Пользователь записывает всю часть выездного мероприятия
2. Транскрибирует в MacWhisper, вырезает нужный фрагмент
3. Сохраняет как "2026.02 ФСТ. Спонсор, за которым идут (Светлана Дмитрук).md"
4. Кладёт файл в inbox
5. Система показывает файл в списке входящих (с пометкой что это транскрипт)
6. Пользователь может прикрепить слайды (как обычно)
7. Пользователь запускает обработку
8. Parse определяет metadata из имени файла (dated offsite паттерн)
9. Transcribe загружает содержимое .md вместо вызова Whisper
10. Далее pipeline работает как обычно: Clean → Longread/Story → Chunk → Save
```

---

## 4. UI

### Inbox — отображение MD-файлов

В списке входящих MD-файлы отображаются наравне с медиафайлами, но с визуальным отличием:

| Элемент | Медиафайл | MD-транскрипт |
|---------|-----------|---------------|
| Иконка | Video/Audio иконка | Document/Text иконка |
| Метка | — | "Транскрипт" бейдж |
| Длительность | Из ffprobe | Оценка по словам |
| Действия | Обработка + Слайды | Обработка + Слайды |

### Step-by-step режим

Шаг Transcribe для MD-файлов показывает:
- "Транскрипт загружен из файла" вместо прогресса Whisper
- Количество слов и оценочная длительность
- Информация о спикерах (если есть метки в тексте)

---

## 5. Форматы содержимого MD-файла

### Вариант A: Один спикер (простой текст)

```
Добрый день, дорогие независимые партнеры! Сегодня мы будем
говорить о том, как строить бизнес в условиях...
```

### Вариант B: Несколько спикеров (plain text, без таймкодов)

```
Беркин Андрей
Добрый день, дорогие независимые партнеры! Я первый раз вас
с тем, что это 10-ая школа уже, поздравляю.

Дмитрук Светлана
Спасибо, Андрей! Я хочу продолжить тему и рассказать о...
```

Формат: имя спикера на отдельной строке (`{Фамилия} {Имя}`), далее текст. Без таймкодов — они относятся к исходной длинной записи и не несут ценности.

Метки спикеров сохраняются при передаче в clean stage — они полезны для последующих этапов:
- **Longread** — Claude видит кто говорит, может структурировать по спикерам
- **Summary** — метки помогают атрибутировать идеи конкретным спикерам

> **На будущее:** рассмотреть выделение имён спикеров через `**` (`**Беркин Андрей**`) — это однозначнее для парсинга и нативно для markdown. Пока plain text, т.к. ручная замена в редакторе неудобна.

---

## 6. Данные

### Изменения существующих моделей

| Сущность | Изменение | Описание |
|----------|-----------|----------|
| `RawTranscript` | Использование существующей модели | Один сегмент с полным текстом, `whisper_model="macwhisper-large-v2"` |
| `VideoMetadata` | Новое поле `speaker_info` | `SpeakerInfo | None = None` — результат парсинга спикеров из MD |

### SpeakerInfo (новая модель)

Модель для хранения информации о спикерах, извлечённой из содержимого MD-файла. Создаётся в v0.64 для отображения в UI, в v0.65 используется для адаптации промптов и шапки чанков.

```python
# backend/app/models/schemas.py
class SpeakerInfo(CamelCaseModel):
    named_speakers: list[str]      # ["Беркин Андрей", "Дмитрук Светлана"]
    anonymous_speakers: list[str]   # ["Speaker3", "Speaker5"]
    scenario: str                   # "single" | "co_speakers" | "lineup" | "qa" | ...
```

Хранится в `VideoMetadata.speaker_info` — доступна во всех stages и saver без изменения сигнатур. Для не-MD файлов — `None`.

### Парсер спикеров (новый модуль)

```python
# backend/app/utils/speaker_utils.py

SPEAKER_PATTERN = re.compile(r'^(Speaker\d+|[А-ЯЁA-Z][а-яёa-z]+ [А-ЯЁA-Z][а-яёa-z]+)$')

def parse_speakers(text: str) -> SpeakerInfo:
    """Анализирует текст MD-файла и определяет спикеров и сценарий."""
    named = set()
    anonymous = set()

    for line in text.splitlines():
        line = line.strip()
        if SPEAKER_PATTERN.match(line):
            if line.startswith("Speaker"):
                anonymous.add(line)
            else:
                named.add(line)

    return SpeakerInfo(
        named_speakers=sorted(named),
        anonymous_speakers=sorted(anonymous),
        scenario=_determine_scenario(len(named), len(anonymous) > 0),
    )

def _determine_scenario(named_count: int, has_anonymous: bool) -> str:
    if named_count <= 1 and not has_anonymous:
        return "single"
    if named_count <= 1 and has_anonymous:
        return "qa"
    if named_count == 2:
        return "co_speakers_qa" if has_anonymous else "co_speakers"
    return "lineup_qa" if has_anonymous else "lineup"
```

> **Подготовка для v0.65:** Парсер и модель создаются в v0.64 для UI-отображения. В v0.65 они переиспользуются для адаптации промптов и шапки чанков — без рефакторинга.

### Создание RawTranscript из MD-файла

```python
# Псевдокод
text = md_file.read_text(encoding="utf-8")
word_count = len(text.split())
estimated_duration = word_count / 130 * 60  # секунды (~130 слов/мин)

transcript = RawTranscript(
    segments=[TranscriptSegment(start=0, end=estimated_duration, text=text)],
    language="ru",
    duration_seconds=estimated_duration,
    whisper_model="macwhisper-large-v2",
    confidence=None,
    processing_time_sec=0,
)

# Парсинг спикеров → в metadata
speaker_info = parse_speakers(text)
metadata.speaker_info = speaker_info
```

---

## 7. Ограничения

| Параметр | Лимит | Обоснование |
|----------|-------|-------------|
| Расширение файла | `.md` | Единственный формат готовых транскриптов |
| Кодировка | UTF-8 | Стандарт для markdown |
| Только offsite | Dated offsite паттерн | Регулярные мероприятия — из видеофайлов |
| Исходный .md в архиве | Копируется без изменения имени | Для повторного запуска после перенастройки |
| Аудио в архиве | Отсутствует | Нет медиафайла — нет audio.mp3 |
| Длительность | Оценка по словам | ~130 слов/мин, приблизительно |
| Мультиспикерность | Отдельное требование | Адаптация промптов — cross-cutting для всех форматов |

---

## 8. План реализации

### Этап 1: Backend — поддержка MD в inbox и pipeline (v0.64)

- [ ] Добавить `.md` в расширения inbox (`routes.py`)
- [ ] Добавить `is_transcript_file()` в `media_utils.py`
- [ ] Адаптировать `TranscribeStage` — загрузка текста из .md вместо Whisper
- [ ] Создание `RawTranscript` из текста файла (один сегмент, `whisper_model="macwhisper-large-v2"`)
- [ ] Оценка `duration_seconds` по количеству слов (~130 слов/мин)
- [ ] Создать `SpeakerInfo` модель в `schemas.py`
- [ ] Создать `backend/app/utils/speaker_utils.py` — парсинг спикеров из текста
- [ ] Добавить `speaker_info: SpeakerInfo | None = None` в `VideoMetadata`
- [ ] В TranscribeStage для MD: парсинг спикеров → `metadata.speaker_info`
- [ ] Обновить clean prompt: сохранять метки спикеров (`Фамилия Имя`, `SpeakerN`) — не удалять как "реплики ведущих"
- [ ] Копирование исходного .md файла в архив (без изменения имени)
- [ ] Адаптировать Save — не копировать audio.mp3 для MD-файлов
- [ ] Проверить, что DATED_OFFSITE_PATTERN корректно парсит имена `.md` файлов

### Этап 2: Frontend — отображение MD-файлов (v0.64)

- [ ] Визуальное отличие MD-файлов в inbox (иконка/бейдж)
- [ ] Адаптировать шаг Transcribe в step-by-step для MD
- [ ] Показ оценочной длительности вместо точной

### Связанное требование: Мультиспикерность

Адаптация промптов longread/story/summary для тем с несколькими спикерами — **[отдельное требование](multi-speaker-support.md)**. Определение сценария программно, по меткам спикеров в MD-файле (MacWhisper diarization).

---

## 9. Тестирование

| Сценарий | Ожидаемый результат |
|----------|---------------------|
| MD-файл в inbox | Отображается в списке с пометкой "Транскрипт" |
| Парсинг имени `2026.02 ФСТ. Тема (Спикер).md` | Корректная VideoMetadata, content_type=educational |
| Парсинг имени `2026.02 ФСТ. # Фамилия (Имена).md` | content_type=leadership |
| Обработка MD с одним спикером | Pipeline проходит полностью, whisper_model="macwhisper-large-v2" |
| Обработка MD с метками спикеров | Clean корректно обрабатывает текст с метками |
| MD + слайды | Слайды прикрепляются и используются в longread/story |
| Оценка длительности | Соответствует формуле words/130*60 |
| Архив для MD-файла | Исходный .md скопирован, нет audio.mp3, остальные файлы присутствуют |
| Парсер: MD с 1 спикером | `speaker_info.scenario == "single"` |
| Парсер: MD с 2 спикерами | `scenario == "co_speakers"`, оба в `named_speakers` |
| Парсер: MD с SpeakerN | `scenario == "qa"`, SpeakerN в `anonymous_speakers` |
| Парсер: MD без меток | `scenario == "single"`, пустые списки |
| Не-MD файл | `speaker_info is None` |
| Clean: метки спикеров | `Фамилия Имя` на отдельных строках сохранены |
| Clean: SpeakerN | `SpeakerN` сохранён как есть |
| UI step-by-step | Показывает количество и имена спикеров из `speaker_info` |

---

## Решённые вопросы

- [x] **Исходный .md в архив** — да, копируется без изменения имени для повторного запуска
- [x] **Метки спикеров** — plain text без таймкодов (`Фамилия Имя` на отдельной строке). Выделение `**` — на будущее
- [x] **whisper_model маркер** — `"macwhisper-large-v2"` (конкретный источник, отображается в UI и metadata BZ2-Bot)
- [x] **Парсер спикеров в v0.64** — создаётся для UI-отображения, переиспользуется в v0.65 для промптов и saver
- [x] **SpeakerInfo в VideoMetadata** — `speaker_info: SpeakerInfo | None = None`, доступна во всех stages
- [x] **Clean prompt** — обновить для сохранения меток спикеров (подготовка для v0.65)

---

## История изменений

| Дата | Версия | Изменения |
|------|--------|-----------|
| 2026-02-19 | 1.0 | Первоначальная версия |
| 2026-02-19 | 1.1 | Подготовка для v0.65: SpeakerInfo + speaker_utils.py, speaker_info в VideoMetadata, clean prompt для меток спикеров |

---

_Документ для планирования в Claude Code_
