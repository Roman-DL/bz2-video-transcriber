# Запрос: Аудит согласованности после Pipeline Optimization (v0.21-v0.26)

## Контекст

В версиях v0.21-v0.26 была реализована масштабная переработка pipeline согласно плану [docs/research/pipeline-optimization-for-rag.md](../research/pipeline-optimization-for-rag.md). Изменения вносились в **5 разных сессиях**, что создаёт риск несогласованности между модулями.

### Реализованные фазы

| Версия | Фаза | Что сделано |
|--------|------|-------------|
| v0.21 | 1 | ContentType (educational/leadership), EventCategory (regular/offsite), структура архива |
| v0.22 | 2 | Глоссарий как контекст LLM вместо regex-замен |
| v0.23 | 3 | 3-компонентные промпты для Longread, StoryStage для leadership |
| v0.24 | 4 | Summary из CleanedTranscript, 3-компонентные промпты |
| v0.25 | 5 | Детерминированное H2-чанкование, изменён порядок pipeline |
| v0.26 | cleanup | Удалён LLM-chunker и chunker_model |

### Новый pipeline (v0.25+)

```
Transcribe → Clean ─┬─→ Longread → Summary → Chunk (H2) → Save  [educational]
                    └─→ Story → Chunk (H2) → Save               [leadership]
```

**Ключевые изменения:**
- Longread/Story генерируются из `CleanedTranscript`, не из chunks
- Summary генерируется из `CleanedTranscript`, не из Longread
- Chunk теперь детерминированный (парсинг H2), не требует LLM
- StoryStage выполняется только для `content_type=leadership`
- LongreadStage и SummarizeStage только для `content_type=educational`

---

## Задача

Провести аудит кода на согласованность изменений. **НЕ тестировать** — только анализ кода.

---

## Области аудита

### 1. Backend: Stage Dependencies и Orchestrator

**Файлы для проверки:**
```
backend/app/services/stages/
├── base.py              # BaseStage, StageContext, depends_on
├── parse_stage.py       # Определяет content_type
├── transcribe_stage.py
├── clean_stage.py       # Глоссарий как контекст?
├── longread_stage.py    # depends_on = ["parse", "clean"]?
├── summarize_stage.py   # depends_on = ["parse", "clean"]? источник = cleaned?
├── story_stage.py       # should_skip() для educational?
├── chunk_stage.py       # depends_on включает longread И story? источник = longread/story?
└── save_stage.py        # Сохраняет правильные файлы по content_type?

backend/app/services/pipeline/
├── orchestrator.py      # Порядок выполнения, ветвление по content_type
├── progress_manager.py  # STAGE_WEIGHTS актуальны?
└── fallback_factory.py  # Fallback создаёт правильные модели?
```

**Чеклист:**
- [ ] `LongreadStage.depends_on` = ["parse", "clean"] (не "chunk"!)
- [ ] `SummarizeStage.depends_on` = ["parse", "clean"] (не "longread"!)
- [ ] `ChunkStage.depends_on` включает "longread" и "story"
- [ ] `StoryStage.should_skip()` возвращает True для educational
- [ ] `LongreadStage.should_skip()` возвращает True для leadership
- [ ] `SummarizeStage.should_skip()` возвращает True для leadership
- [ ] Orchestrator вызывает этапы в правильном порядке
- [ ] Нет зависимостей от удалённого `chunker.py`

### 2. Backend: Generators и их inputs

**Файлы для проверки:**
```
backend/app/services/
├── cleaner.py           # _load_glossary_text() существует и используется?
├── longread_generator.py # Принимает CleanedTranscript?
├── summary_generator.py  # Принимает CleanedTranscript?
└── story_generator.py    # Принимает CleanedTranscript?

backend/app/utils/
└── h2_chunker.py        # chunk_by_h2() существует и корректен?
```

**Чеклист:**
- [ ] `LongreadGenerator.generate()` принимает `CleanedTranscript`
- [ ] `SummaryGenerator.generate()` принимает `CleanedTranscript`
- [ ] `StoryGenerator.generate()` принимает `CleanedTranscript`
- [ ] `chunk_by_h2()` парсит markdown и возвращает `TranscriptChunks`
- [ ] Cleaner использует glossary как контекст LLM

### 3. Backend: Step API

**Файлы для проверки:**
```
backend/app/api/
├── step_routes.py       # Endpoints для step-by-step
└── cache_routes.py      # Rerun logic
```

**Чеклист:**
- [ ] `POST /step/longread` принимает `cleaned_transcript`
- [ ] `POST /step/summarize` принимает `cleaned_transcript`
- [ ] `POST /step/story` принимает `cleaned_transcript`
- [ ] `POST /step/chunk` принимает `markdown_content` (не chunks)
- [ ] Cache rerun для longread использует cleaned как источник
- [ ] Нет endpoints для старого chunker

### 4. Backend: Pydantic Models

**Файлы для проверки:**
```
backend/app/models/
├── schemas.py           # Request/Response models
└── cache.py             # CacheStageName enum
```

**Чеклист:**
- [ ] `StepLongreadRequest` содержит `cleaned_transcript`
- [ ] `StepSummarizeRequest` содержит `cleaned_transcript`
- [ ] `StepStoryRequest` содержит `cleaned_transcript`
- [ ] `StepChunkRequest` содержит `markdown_content` или аналог
- [ ] `VideoMetadata` содержит `content_type`, `event_category`
- [ ] `CacheStageName` не содержит CHUNKING (удалён в v0.26)

### 5. Frontend: Components и Workflow

**Файлы для проверки:**
```
frontend/src/
├── App.tsx              # Основной layout
├── components/
│   ├── VideoDetails.tsx # Отображает content_type?
│   ├── StepByStep.tsx   # Условный workflow по content_type?
│   ├── LongreadView.tsx # Существует?
│   ├── StoryView.tsx    # Существует для leadership?
│   ├── SummaryView.tsx  # Существует?
│   └── ChunksView.tsx   # Обновлён для нового chunk API?
└── api/
    └── client.ts        # API calls соответствуют новым endpoints?
```

**Чеклист:**
- [ ] UI отображает `content_type` (educational/leadership)
- [ ] Step-by-step workflow разный для educational и leadership
- [ ] `StoryView` существует и рендерит 8 блоков
- [ ] API client использует правильные request bodies
- [ ] Нет вызовов старого chunker API

### 6. Config и Prompts

**Файлы для проверки:**
```
config/
├── prompts/
│   ├── cleaner_system.md    # Инструкции по глоссарию?
│   ├── cleaner_user.md      # {glossary} placeholder?
│   ├── longread_system.md   # 3-компонентная структура?
│   ├── longread_instructions.md
│   ├── longread_template.md
│   ├── summary_system.md
│   ├── summary_instructions.md
│   ├── summary_template.md
│   ├── story_system.md
│   ├── story_instructions.md
│   └── story_template.md
├── models.yaml          # Нет секций chunker?
└── glossary.yaml        # Формат для LLM контекста?
```

**Чеклист:**
- [ ] Cleaner промпты содержат инструкции по глоссарию
- [ ] `cleaner_user.md` содержит `{glossary}` placeholder
- [ ] Longread/Summary/Story имеют 3-компонентную структуру (system + instructions + template)
- [ ] Нет промптов `chunker*.md` (удалены в v0.25)
- [ ] `models.yaml` не содержит секций `chunker:`

### 7. Мёртвый код и импорты

**Поиск:**
```bash
# Импорты удалённых модулей
grep -r "from app.services.chunker" backend/
grep -r "from app.services import chunker" backend/
grep -r "SemanticChunker" backend/

# Старые настройки
grep -r "chunker_model" backend/
grep -r "CHUNKER_MODEL" .

# Старые методы
grep -r "def chunk\(" backend/app/services/  # кроме h2_chunker.py
grep -r "TranscriptChunks" backend/  # где используется?
```

**Чеклист:**
- [ ] Нет импортов `chunker.py`
- [ ] Нет использования `SemanticChunker`
- [ ] Нет `chunker_model` в settings
- [ ] `TranscriptChunks` используется только в chunk_stage и saver

---

## Ожидаемый output

1. **Таблица несоответствий:**
   | Файл | Проблема | Ожидалось | Фактически |
   |------|----------|-----------|------------|

2. **Критические проблемы** (блокируют работу)

3. **Некритичные проблемы** (могут вызвать баги)

4. **Рекомендации** по исправлению

---

## Примечания

- Код в `backend/app/config.py` уже содержит `load_prompt()` с fallback логикой
- Stage abstraction описана в `docs/pipeline/stages.md`
- ADR документы в `docs/adr/`
- Не редактировать код — только анализ
