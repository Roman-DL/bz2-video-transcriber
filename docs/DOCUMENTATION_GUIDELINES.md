# Гайдлайны по документированию

Принципы документирования кода для проекта bz2-video-transcriber.

---

## Главный принцип: Код — источник истины

- **Docstrings в коде** всегда актуальны (меняются вместе с кодом)
- **Внешняя документация** (.md файлы) описывает архитектуру и интеграцию
- **ИИ читает код напрямую** — детали реализации не нужно дублировать

---

## Что документировать во внешних .md файлах

| Категория | Пример | Почему нужно |
|-----------|--------|--------------|
| Архитектура | Поток данных pipeline | Не видно из одного файла |
| Интеграция | Как сервисы связаны между собой | Требует понимания системы |
| Решения | Почему выбран подход A, а не B | Код не объясняет "почему" |
| Конфигурация | Параметры, URL сервисов, модели | Меняются при деплое |
| Форматы данных | Структура JSON/YAML | Контракты между компонентами |
| Деплой | Инструкции по развёртыванию | Не связано с кодом |

---

## Что НЕ документировать во внешних .md файлах

| Категория | Почему НЕ документируем |
|-----------|-------------------------|
| Сигнатуры методов | Устаревают при рефакторинге |
| Константы и переменные | ИИ прочитает из кода |
| Приватные методы (`_method`) | Детали реализации |
| Примеры кода с конкретными значениями | Копипаст устаревает |
| Номера строк | Меняются при любом редактировании |
| Полные листинги кода | Дублирование → рассинхронизация |

---

## Формат docstrings в коде

Используем Google-style docstrings. Обязательны для **публичных методов**.

```python
def method(self, arg1: Type, arg2: Type) -> ReturnType:
    """
    Краткое описание в одну строку.

    Расширенное описание если нужно (опционально).

    Args:
        arg1: Описание первого аргумента
        arg2: Описание второго аргумента

    Returns:
        Описание возвращаемого значения

    Raises:
        ValueError: Когда выбрасывается это исключение
    """
```

**Для классов:**
```python
class ServiceName:
    """
    Краткое описание сервиса.

    Расширенное описание с примером использования.

    Example:
        async with AIClient(settings) as client:
            service = ServiceName(client, settings)
            result = await service.process(data)
    """
```

---

## Когда обновлять внешнюю документацию

| Изменение в коде | Обновить docs? | Что обновить |
|------------------|----------------|--------------|
| Новый сервис/этап pipeline | Да | docs/pipeline/ |
| Рефакторинг метода | Нет | Только docstring в коде |
| Изменение публичного API | Да | api-reference.md |
| Новая конфигурация | Да | deployment.md, CLAUDE.md |
| Баг-фикс | Нет | — |
| Архитектурное решение | Да | Зафиксировать "почему" |
| Новый формат данных | Да | data-formats.md |

---

## Тестирование

### Встроенные тесты

Каждый сервис содержит тесты в блоке `if __name__ == "__main__"`.

**Запуск:**
```bash
python -m backend.app.services.<service_name>
```

**Документирование:** в docstring модуля перечислить что тестируется.

### Что тестировать

1. Парсинг входных данных
2. Обработка ошибок (невалидный JSON, недоступный сервис)
3. Вычисляемые поля и форматирование
4. Интеграция с внешними сервисами (если доступны)

---

## Структура документации проекта

```
docs/
├── DOCUMENTATION_GUIDELINES.md  # Этот файл
├── architecture.md              # Общая архитектура
├── api-reference.md             # API внешних сервисов
├── data-formats.md              # Форматы данных
├── deployment.md                # Инструкции по деплою
└── pipeline/                    # Документация этапов
    ├── README.md                # Обзор pipeline
    ├── 01-parse.md
    ├── 02-transcribe.md
    ├── ...
    └── error-handling.md
```

---

## Чек-лист при добавлении нового сервиса

- [ ] Docstrings для класса и публичных методов
- [ ] Встроенные тесты в `if __name__ == "__main__"`
- [ ] Добавить этап в docs/pipeline/ (если новый этап)
- [ ] Обновить docs/architecture.md (если меняется архитектура)
- [ ] Обновить CLAUDE.md (если новая конфигурация)

---

## Примеры хорошей и плохой документации

### Хорошо (архитектура и "почему")

```markdown
## Двухэтапная очистка

Очистка транскрипта выполняется в два этапа:
1. **Глоссарий** — быстрая замена терминов (Python regex)
2. **LLM** — удаление слов-паразитов (Ollama)

Почему два этапа: глоссарий гарантирует точность терминов,
LLM обрабатывает естественный язык.
```

### Плохо (дублирование кода)

```markdown
## Метод clean()

```python
async def clean(self, raw_transcript: RawTranscript, metadata: VideoMetadata) -> CleanedTranscript:
    original_text = raw_transcript.full_text
    text_after_glossary, corrections = self._apply_glossary(original_text)
    ...
```

Этот код устареет при первом же рефакторинге.
```
